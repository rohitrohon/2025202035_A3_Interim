TrackerResponse TrackerClient::announce_to_tracker(TrackerState& tracker, 
                                                 const std::string& info_hash, 
                                                 Event event) {
    // Build the announce request
    std::stringstream request_ss;
    request_ss << "ANNOUNCE " << info_hash << " HTTP/1.1\r\n";
    request_ss << "Peer-ID: " << peer_id_ << "\r\n";
    request_ss << "Port: " << port_ << "\r\n";
    request_ss << "Uploaded: " << stats_.uploaded << "\r\n";
    request_ss << "Downloaded: " << stats_.downloaded << "\r\n";
    request_ss << "Left: " << stats_.left << "\r\n";
    
    if (event != Event::NONE) {
        request_ss << "Event: " << event_to_string(event) << "\r\n";
    }
    
    if (!tracker.tracker_id.empty()) {
        request_ss << "Tracker-ID: " << tracker.tracker_id << "\r\n";
    }
    
    request_ss << "\r\n"; // End of headers
    
    std::string request = request_ss.str();
    std::string response;
    if (send(sock, request.c_str(), request.length(), 0) < 0) {
        close(sock);
        return false;
    }
    
    // Receive response
    char buffer[4096];
    ssize_t bytes_received;
    while ((bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0)) > 0) {
        buffer[bytes_received] = '\0';
        response.append(buffer);
    }
    
    close(sock);
    return !response.empty();
}

// TrackerClient implementation
TrackerClient::TrackerClient(const std::string& peer_id, uint16_t port)
    : peer_id_(peer_id)
    , port_(port)
    , running_(false)
    , stats_() {
    stats_.last_update = std::chrono::steady_clock::now();
}

TrackerClient::~TrackerClient() {
    stop();
}

void TrackerClient::start() {
    if (running_.load()) {
        return;
    }
    
    running_ = true;
    announce_thread_ = std::thread(&TrackerClient::announce_loop, this);
}

void TrackerClient::stop() {
    if (!running_.load()) {
        return;
    }
    
    running_ = false;
    
    if (announce_thread_.joinable()) {
        announce_thread_.join();
    }
}

void TrackerClient::set_peer_list_callback(PeerListCallback callback) {
    std::lock_guard<std::mutex> lock(peers_mutex_);
    peer_list_callback_ = std::move(callback);
void TrackerClient::announce(const std::string& info_hash, Event event) {
    std::vector<TrackerState> trackers_copy;
    {
        std::lock_guard<std::mutex> lock(trackers_mutex_);
        trackers_copy = trackers_;
    }
    
    for (auto& tracker : trackers_copy) {
        try {
            std::string request;
            {
                std::stringstream request_ss;
                request_ss << "ANNOUNCE " << info_hash << " HTTP/1.1\r\n";
                request_ss << "Peer-ID: " << peer_id_ << "\r\n";
                request_ss << "Port: " << port_ << "\r\n";
                request_ss << "Uploaded: " << stats_.uploaded << "\r\n";
                request_ss << "Downloaded: " << stats_.downloaded << "\r\n";
                request_ss << "Left: " << stats_.left << "\r\n";
                it->failure_reason.clear();
                
                if (!response.tracker_id.empty()) {
                    it->tracker_id = response.tracker_id;
                }
                
                if (response.interval > 0) {
                    it->interval = response.interval;
                }
                
                if (response.min_interval > 0) {
                    it->min_interval = response.min_interval;
                }
            }
        } catch (const std::exception& e) {
            handle_error(std::string("Error announcing to tracker ") + tracker.url + ": " + e.what());
            
            // Update tracker state with error
            std::lock_guard<std::mutex> lock(trackers_mutex_);
            auto it = std::find_if(trackers_.begin(), trackers_.end(),
                                 [&tracker](const TrackerState& t) { return t.url == tracker.url; });
            
            if (it != trackers_.end()) {
                it->failure_reason = e.what();
            }
        }
    }
}

std::vector<PeerInfo> TrackerClient::get_peers() const {
    std::lock_guard<std::mutex> lock(peers_mutex_);
    return peers_;
}

void TrackerClient::update_stats(uint64_t downloaded, uint64_t uploaded, uint64_t left) {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    
    stats_.downloaded_prev = stats_.downloaded;
    stats_.uploaded_prev = stats_.uploaded;
    
    stats_.downloaded = downloaded;
    stats_.uploaded = uploaded;
    stats_.left = left;
    stats_.last_update = std::chrono::steady_clock::now();
}

TrackerStats TrackerClient::get_stats() const {
    std::lock_guard<std::mutex> lock(stats_mutex_);
    return stats_;
}

void TrackerClient::announce_loop() {
    while (running_.load()) {
        try {
            // Get the list of trackers that need to be announced to
            std::vector<TrackerState> trackers_to_announce;
            auto now = std::chrono::steady_clock::now();
            
            {
                std::lock_guard<std::mutex> lock(trackers_mutex_);
                
                for (const auto& tracker : trackers_) {
                    auto time_since_last_announce = std::chrono::duration_cast<std::chrono::seconds>(
                        now - tracker.last_announce).count();
                    
                    if (!tracker.announced || time_since_last_announce >= tracker.interval) {
                        trackers_to_announce.push_back(tracker);
                    }
                }
            }
            
            // Announce to each tracker
            for (const auto& tracker : trackers_to_announce) {
                if (!running_.load()) {
                    break;
                }
                
                // For now, we'll just announce with an empty info_hash
                // In a real implementation, you would get the info_hash from the torrent file
                announce("", Event::NONE);
            }
            
            // Sleep for a short time before checking again
            std::this_thread::sleep_for(std::chrono::seconds(5));
            
        } catch (const std::exception& e) {
            handle_error(std::string("Error in announce loop: ") + e.what());
            std::this_thread::sleep_for(std::chrono::seconds(10));
        }
    }
}

void TrackerClient::update_peers(const std::vector<PeerInfo>& new_peers) {
    std::lock_guard<std::mutex> lock(peers_mutex_);
    
    // Merge new peers with existing ones
    for (const auto& new_peer : new_peers) {
        auto it = std::find_if(peers_.begin(), peers_.end(),
                             [&new_peer](const PeerInfo& p) { 
                                 return p.ip == new_peer.ip && p.port == new_peer.port; 
                             });
        
        if (it == peers_.end()) {
            peers_.push_back(new_peer);
        }
    }
    
    // Notify the callback if set
    if (peer_list_callback_) {
        peer_list_callback_(peers_);
    }
}
                    // In a real implementation, you would parse the binary format
                }
            }
            
            return result;
            
        } catch (const json::exception&) {
            // Not JSON, try to parse as bencode (simplified)
            // In a real implementation, you would use a proper bencode parser
            throw std::runtime_error("Bencode parsing not implemented");
        }
        
    } catch (const std::exception& e) {
        result.failure_reason = std::string("Failed to parse tracker response: ") + e.what();
        return result;
    }
    
    return result;
}

void TrackerClient::handle_error(const std::string& error) {
    if (error_callback_) {
        error_callback_(error);
    }
}


} // namespace p2p
